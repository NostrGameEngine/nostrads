plugins {
    id 'application'
    id 'org.graalvm.buildtools.native' version '0.10.6'
    id "com.diffplug.spotless" version "7.0.2"  
}

 
def projectVersion = System.getenv("VERSION")
if (projectVersion == null || projectVersion.trim().isEmpty()) {
    projectVersion = rootProject.ext.baseVersion
}
def projectGroup = System.getenv("GROUP") ?: rootProject.ext.baseGroup 

println "Using project version: ${projectVersion}"
println "Using project group: ${projectGroup}"

version = projectVersion
group   = projectGroup


repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url = uri("https://central.sonatype.com/repository/maven-snapshots")
    }
    maven {
        url = "https://maven.rblb.it/NostrGameEngine/libdatachannel-java"
    }
}

dependencies {
    implementation "jakarta.annotation:jakarta.annotation-api:2.1.1"
    implementation project(":nostrads")
    implementation "org.ngengine:nge-platform-jvm:${project.version.endsWith('-SNAPSHOT') ? rootProject.ext.ngePlatformVersionSnapshot : rootProject.ext.ngePlatformVersion}"

    testImplementation libs.junit
    testImplementation "org.ngengine:nge-platform-jvm:${project.version.endsWith('-SNAPSHOT') ? rootProject.ext.ngePlatformVersionSnapshot : rootProject.ext.ngePlatformVersion}"
    testImplementation "junit:junit:4.13.2"   
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
        vendor = JvmVendorSpec.ADOPTIUM 
        implementation = JvmImplementation.VENDOR_SPECIFIC
    }
}

tasks.register('addLicenseHeaders') {
    description = 'Adds license headers to Java files if missing'
    group = 'formatting'
    
    def srcFiles = fileTree(dir: 'src', include: '**/java/**/*.java')
    
    def licenseText = file("${project.rootDir}/LICENSE").text
    licenseText = licenseText.readLines().collect { " * " + it }.join("\n")
    licenseText = "/**\n" + licenseText + "\n */"

    doLast {
        def licenseHeader = licenseText
        def headerPattern = ~/(?s)\/\*\*.*?Copyright.*?\*\//
        
        srcFiles.each { file ->
            def content = file.text
            
            if (!(content =~ headerPattern)) {
                logger.info("Adding license header to: ${file.path}")
                
                def packageMatcher = content =~ /(?m)^package\s+[\w.]+;/
                
                if (packageMatcher.find()) {
                    def position = packageMatcher.start()
                    def newContent = content.substring(0, position) + 
                                     licenseHeader + 
                                     "\n\n" + 
                                     content.substring(position)
                    file.text = newContent
                } else {
                    file.text = licenseHeader + "\n\n" + content
                }
            } else {
                logger.debug("License header already exists in: ${file.path}")
            }
        }
    }
}

tasks.named('spotlessApply').configure {
    dependsOn tasks.named('addLicenseHeaders')
}


spotless {
    java {
        target 'src/*/**/*.java'      

        
        importOrder()
        removeUnusedImports()
        prettier(["prettier": "2.8.8", "prettier-plugin-java": "2.2.0"])
        .config([
            "parser": "java", 
            "tabWidth": 4, 
            "printWidth": 128,
            "endOfLine": "lf",
            "useTabs": false
        ])
        
        
        bumpThisNumberIfACustomStepChanges(1)
    }
    
     
}
application {
    mainClass = "org.ngengine.nostrads.DelegateServer"
}


graalvmNative {
    toolchainDetection = true
    metadataRepository {
        enabled = true
    }
    binaries {
        main {
        
            def buildName =  "${rootProject.name}";
            imageName = buildName
            def initAtRuntime = file("${project.projectDir}/graal.initialize-at-runtime.conf")
                .text
                .split("\\r?\\n")
                .findAll { it && !it.startsWith('#') && !it.trim().isEmpty() }
                .join(',')

            mainClass = application.mainClass.get()
                def arguments = [
                '--report-unsupported-elements-at-runtime',
                '--install-exit-handlers',
                '-H:+ReportExceptionStackTraces',
                '-H:+PrintClassInitialization',
                '--initialize-at-run-time=' + initAtRuntime,
                '--no-server',
                '--enable-url-protocols=http,https,file',
                '--link-at-build-time',
                '-H:+UnlockExperimentalVMOptions',
                '--enable-native-access=ALL-UNNAMED',
                '-H:+StaticExecutableWithDynamicLibC',
                '-march=compatibility',
                '-Djava.awt.headless=true',
                "-Djava.util.logging.config.file=release-logging.properties",
                '-H:IncludeResources=.*',
                "-H:IncludeResources=release-logging.properties",
                "-H:Log=registerResource:3",
                '-H:Name=' + buildName,
                "-H:ConfigurationFileDirectories=${project.projectDir}/trace"
            ]
            
            // Add G1 GC only if linux
            if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
                arguments.add('--gc=G1')
            }
            
            buildArgs.addAll(arguments)
            sharedLibrary = false       
        }
    }
}

configurations { 
    nativeImageCompileOnly {
        canBeResolved = true
    }
}


task traceNative(type: JavaExec) {
    group = 'graalvm'
    description = 'Trace reflection and resource usage'
    mainClass =  application.mainClass.get()
    classpath = sourceSets.main.runtimeClasspath
    def jvmArgsList = [
        "-agentlib:native-image-agent=config-merge-dir=${project.projectDir}/trace",
        '-Djava.awt.headless=true'
    ]
    jvmArgsList.add("-Djava.util.logging.config.file=${project.projectDir}/logging.properties")

    // add '-XstartOnFirstThread if macos
    if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        jvmArgsList.add('-XstartOnFirstThread')
    }
    
    jvmArgs = jvmArgsList

    // app args
    args = [
        "--test"
    ]

    systemProperty 'java.awt.headless', 'false'
    systemProperty 'testMode', 'true'
    doFirst {
        println "Tracing to: ${project.projectDir}/trace"
        println "Run the application and exercise ALL features:"
        println "- Load different asset types (textures, models, sounds)"
        println "- Use UI components"
        println "- Trigger network operations"
        println "- Test different game states"
        println "Then close the application normally."
    }
    doLast {
        println "Tracing complete! Generated/updated files:"
        fileTree("${project.projectDir}/trace").each { file ->
            if (file.isFile()) {
                println "  - ${file.name} (${file.length()} bytes)"
            }
        }
    }
}



def getOsName(){
    def osName = org.gradle.internal.os.OperatingSystem.current().getName().toLowerCase()

    if (org.gradle.internal.os.OperatingSystem.current().isWindows()){
        osName = "windows"
    } else if (org.gradle.internal.os.OperatingSystem.current().isMacOsX()) {
        osName = "macos"
    } else if (org.gradle.internal.os.OperatingSystem.current().isLinux()) {
        osName = "linux"
    }

    return osName
}
task buildNativeExecutable {
    group = 'graalvm'
    description = 'Build native executable for current platform'
    dependsOn 'nativeCompile' 
    doLast {
        def buildDirNative = "${project.buildDir}/native/nativeCompile"
        def executableName = graalvmNative.binaries.main.imageName.get()
        if (org.gradle.internal.os.OperatingSystem.current().isWindows()) {
            executableName += '.exe'
        }
        
        def osName = getOsName()
        def osArch = System.getProperty("os.arch").toLowerCase()
        def buildName =  "${rootProject.name}-${project.version}-${osName}-${osArch}";

        def distDir = file("${rootProject.projectDir}/dist/${buildName}.buildNative")
        distDir.mkdirs()
        
        copy {
            from buildDirNative
            into distDir
            exclude '**/reports/**'
            exclude '**/*.report'
            exclude '**/*.dmp'
            exclude '**/*.log'
        }
        
        println "Native executable built: ${buildDirNative}/${executableName}"
        println "All native build files copied to: ${distDir}"
    }
}

